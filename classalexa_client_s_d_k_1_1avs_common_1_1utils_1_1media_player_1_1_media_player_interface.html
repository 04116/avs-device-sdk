<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>alexaClientSDK</b></li><li class="navelem"><b>avsCommon</b></li><li class="navelem"><b>utils</b></li><li class="navelem"><b>mediaPlayer</b></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_media_player_interface_8h_source.html">MediaPlayerInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map" id="alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1capability_agents_1_1speech_synthesizer_1_1test_1_1_mock_media_player.html" title="alexaClientSDK::capability\lAgents::speechSynthesizer\l::test::MockMediaPlayer" alt="" coords="275,5,458,57"/>
<area shape="rect" id="node3" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html" title="alexaClientSDK::integration\l::test::TestMediaPlayer" alt="" coords="275,81,459,120"/>
<area shape="rect" id="node4" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html" title="alexaClientSDK::mediaPlayer\l::MediaPlayer" alt="" coords="269,144,465,183"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ea8410b0e942e263e7b534f88b30ee3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6ea8410b0e942e263e7b534f88b30ee3">~MediaPlayerInterface</a> ()=default</td></tr>
<tr class="separator:a6ea8410b0e942e263e7b534f88b30ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f7a1d8fe9ef77ead9f9a70e533ffd"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a863f7a1d8fe9ef77ead9f9a70e533ffd">setSource</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt; attachmentReader)=0</td></tr>
<tr class="separator:a863f7a1d8fe9ef77ead9f9a70e533ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df36422c7caadefdd438f4c938ed7e4"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6df36422c7caadefdd438f4c938ed7e4">setSource</a> (const std::string &amp;url)=0</td></tr>
<tr class="separator:a6df36422c7caadefdd438f4c938ed7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af938277a89ad00f5d4b1884dee16080f"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#af938277a89ad00f5d4b1884dee16080f">setSource</a> (std::shared_ptr&lt; std::istream &gt; stream, bool repeat)=0</td></tr>
<tr class="separator:af938277a89ad00f5d4b1884dee16080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b75cc675041653fc26c5e07b7083f33"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6b75cc675041653fc26c5e07b7083f33">setOffset</a> (std::chrono::milliseconds offset)</td></tr>
<tr class="separator:a6b75cc675041653fc26c5e07b7083f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e55afe1f90c135f767824ea9e7de56"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a39e55afe1f90c135f767824ea9e7de56">play</a> ()=0</td></tr>
<tr class="separator:a39e55afe1f90c135f767824ea9e7de56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7034677f0614203a26f31475f16e324"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ac7034677f0614203a26f31475f16e324">stop</a> ()=0</td></tr>
<tr class="separator:ac7034677f0614203a26f31475f16e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dc008a6c4d2b79da4d30d8ae82432b"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#aa3dc008a6c4d2b79da4d30d8ae82432b">pause</a> ()=0</td></tr>
<tr class="separator:aa3dc008a6c4d2b79da4d30d8ae82432b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb22095833dc3e9967fdb45c289332bd"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#afb22095833dc3e9967fdb45c289332bd">resume</a> ()=0</td></tr>
<tr class="separator:afb22095833dc3e9967fdb45c289332bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a4f64754a231a7041fba9b5c27d32b"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a31a4f64754a231a7041fba9b5c27d32b">getOffsetInMilliseconds</a> ()=0</td></tr>
<tr class="separator:a31a4f64754a231a7041fba9b5c27d32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612495025a57c1bab88e8be5f7c0bbf4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a612495025a57c1bab88e8be5f7c0bbf4">setObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt; playerObserver)=0</td></tr>
<tr class="separator:a612495025a57c1bab88e8be5f7c0bbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A MediaPlayer allows for sourcing, playback control, navigation, and querying the state of media content. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ea8410b0e942e263e7b534f88b30ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea8410b0e942e263e7b534f88b30ee3">&#9670;&nbsp;</a></span>~MediaPlayerInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::~MediaPlayerInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a31a4f64754a231a7041fba9b5c27d32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a4f64754a231a7041fba9b5c27d32b">&#9670;&nbsp;</a></span>getOffsetInMilliseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getOffsetInMilliseconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the offset, in milliseconds, of the media stream.</p>
<dl class="section return"><dt>Returns</dt><dd>If a stream is playing, the offset in milliseconds that the stream has been playing, if there is no stream playing it returns <code>-1</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a5a20c190023f20c4b6bedbc15838930e">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#a4fb2802491ca78b8aadada78dc70817a">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="aa3dc008a6c4d2b79da4d30d8ae82432b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dc008a6c4d2b79da4d30d8ae82432b">&#9670;&nbsp;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pause playing the audio. Once audio has been paused, calling <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#afb22095833dc3e9967fdb45c289332bd">resume()</a></code> will start the audio. The source should be set before issuing <code>pause</code>. If <code>pause</code> is called without setting source, it will return an error. Calling <code>pause</code> will only have an effect when audio is currently playing. Calling <code>pause</code> in all other states will have no effect, and result in a return of <code>FAILURE</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to pause was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackPaused</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae00393c7aa4f4f0419ffc393bebf00e4">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#abf035d1ff2c2790960462f84e65922c2">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="a39e55afe1f90c135f767824ea9e7de56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e55afe1f90c135f767824ea9e7de56">&#9670;&nbsp;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::play </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start playing audio. The source should be set before issuing <code>play</code>. If <code>play</code> is called without setting source, it will return an error. If <code>play</code> is called when audio is already playing, there is no effect. Status returned will be <code>SUCCESS</code>. If <code>play</code> is called again after <code>stop</code> on the same source, then the audio plays from the beginning.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to play was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackStarted</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#aef8c4efd980ba7d185a4079d3c7bedaf">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#af1db21a46c9b81a3b10b8a51044b8e0e">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="afb22095833dc3e9967fdb45c289332bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb22095833dc3e9967fdb45c289332bd">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resume playing the paused audio. The source should be set before issuing <code>resume</code>. If <code>resume</code> is called without setting source, it will return an error. Calling <code>resume</code> will only have an effect when audio is currently paused. Calling <code>resume</code> in other states will have no effect, and result in a return of <code>FAILURE</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to play was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackResumed</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ac7348e9604a83b11196ecddf494dec86">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#a26435603f94939984606747c6cf37260">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="a612495025a57c1bab88e8be5f7c0bbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612495025a57c1bab88e8be5f7c0bbf4">&#9670;&nbsp;</a></span>setObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>playerObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets an observer to be notified when playback state changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playerObserver</td><td>The observer to send the notifications to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1capability_agents_1_1speech_synthesizer_1_1test_1_1_mock_media_player.html#aefaea85e4c7d0fcf5e94f44bcf6841e9">alexaClientSDK::capabilityAgents::speechSynthesizer::test::MockMediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a271e75fecb39b734cafb9f1260611e79">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#a2f63842abe4e76381bbf67598413aa33">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="a6b75cc675041653fc26c5e07b7083f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b75cc675041653fc26c5e07b7083f33">&#9670;&nbsp;</a></span>setOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setOffset </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO ACSDK-423: Implement setOffset behavior. </p>

</div>
</div>
<a id="a863f7a1d8fe9ef77ead9f9a70e533ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863f7a1d8fe9ef77ead9f9a70e533ffd">&#9670;&nbsp;</a></span>setSource() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt;&#160;</td>
          <td class="paramname"><em>attachmentReader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source to play. The source should be set before issuing <code>play</code> or <code>stop</code>.</p>
<p>The <code>MediaPlayer</code> can handle only one source at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentReader</td><td>Object with which to read an incoming audio attachment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the source was set successfully else <code>FAILURE</code>. If setSource is called when audio is currently playing, the playing audio will be stopped and the source set to the new value. If there is an error stopping the player, this will return <code>FAILURE</code>. </dd></dl>

</div>
</div>
<a id="a6df36422c7caadefdd438f4c938ed7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df36422c7caadefdd438f4c938ed7e4">&#9670;&nbsp;</a></span>setSource() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source to play. The source should be set before issuing <code>play</code> or <code>stop</code>.</p>
<p>The <code>MediaPlayer</code> can handle only one source at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to set as the source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the source was set successfully else <code>FAILURE</code>. If setSource is called when audio is currently playing, the playing audio will be stopped and the source set to the new value. If there is an error stopping the player, this will return <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae302858b924dc8600e5a10a754d299a2">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#ab24cc092176ee12b3c34015aabbf14c1">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="af938277a89ad00f5d4b1884dee16080f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af938277a89ad00f5d4b1884dee16080f">&#9670;&nbsp;</a></span>setSource() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; std::istream &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source to play. The source should be set before issuing <code>play</code> or <code>stop</code>.</p>
<p>The <code>MediaPlayer</code> can handle only one source at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Object with which to read an incoming audio stream. </td></tr>
    <tr><td class="paramname">repeat</td><td>Whether the audio stream should be played in a loop until stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the the source was set successfully else <code>FAILURE</code>. If setSource is called when audio is currently playing, the playing audio will be stopped and the source set to the new value. If there is an error stopping the player, this will return <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a1b20efddb45b45a9347a75be8f7f05ad">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#aa14488d1af1e434c7e4de23e90d81ce6">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<a id="ac7034677f0614203a26f31475f16e324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7034677f0614203a26f31475f16e324">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MediaPlayerStatus alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop playing the audio. Once audio has been stopped, starting playback again will start from the beginning. The source should be set before issuing <code>stop</code>. If <code>stop</code> is called without setting source, it will return an error. If <code>stop</code> is called when audio has already stopped, there is no effect. Status returned will be <code>SUCCESS</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to stop was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackStarted</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a56c3be9e651bb31e2084293db4d617e0">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1integration_1_1test_1_1_test_media_player.html#a34f9ce483a869c3f4b3ad473cb4a36dc">alexaClientSDK::integration::test::TestMediaPlayer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/kcecka/projects/avs-cpp-sdk/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/<a class="el" href="_media_player_interface_8h_source.html">MediaPlayerInterface.h</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 1.0.1 - Copyright 2016-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
