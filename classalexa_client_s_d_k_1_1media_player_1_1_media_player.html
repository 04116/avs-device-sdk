<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::mediaPlayer::MediaPlayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>alexaClientSDK</b></li><li class="navelem"><b>mediaPlayer</b></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classalexa_client_s_d_k_1_1media_player_1_1_media_player-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::mediaPlayer::MediaPlayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_media_player_8h_source.html">MediaPlayer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for alexaClientSDK::mediaPlayer::MediaPlayer:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1media_player_1_1_media_player__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1media_player_1_1_media_player_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1media_player_1_1_media_player_inherit__map" id="alexa_client_s_d_k_1_1media_player_1_1_media_player_inherit__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html" title="alexaClientSDK::avsCommon\l::utils::mediaPlayer::MediaPlayer\lInterface" alt="" coords="5,5,221,57"/>
<area shape="rect" id="node3" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html" title="alexaClientSDK::mediaPlayer\l::PipelineInterface" alt="" coords="15,81,211,120"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for alexaClientSDK::mediaPlayer::MediaPlayer:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1media_player_1_1_media_player__coll__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1media_player_1_1_media_player_coll__map" alt="Collaboration graph"/></div>
<map name="alexa_client_s_d_k_1_1media_player_1_1_media_player_coll__map" id="alexa_client_s_d_k_1_1media_player_1_1_media_player_coll__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html" title="alexaClientSDK::avsCommon\l::utils::mediaPlayer::MediaPlayer\lInterface" alt="" coords="5,5,221,57"/>
<area shape="rect" id="node3" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html" title="alexaClientSDK::mediaPlayer\l::PipelineInterface" alt="" coords="15,81,211,120"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a3084309902d84b2315005fe218ba3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a9a3084309902d84b2315005fe218ba3f">~MediaPlayer</a> ()</td></tr>
<tr class="separator:a9a3084309902d84b2315005fe218ba3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overridden MediaPlayerInterface methods.</div></td></tr>
<tr class="memitem:ad7323d02b91eb1dccbd8373287d1bd46"><td class="memItemLeft" align="right" valign="top"><a id="ad7323d02b91eb1dccbd8373287d1bd46"></a>
avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><b>setSource</b> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt; attachmentReader) override</td></tr>
<tr class="separator:ad7323d02b91eb1dccbd8373287d1bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b20efddb45b45a9347a75be8f7f05ad"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a1b20efddb45b45a9347a75be8f7f05ad">setSource</a> (std::shared_ptr&lt; std::istream &gt; stream, bool repeat) override</td></tr>
<tr class="separator:a1b20efddb45b45a9347a75be8f7f05ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae302858b924dc8600e5a10a754d299a2"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae302858b924dc8600e5a10a754d299a2">setSource</a> (const std::string &amp;url) override</td></tr>
<tr class="separator:ae302858b924dc8600e5a10a754d299a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8c4efd980ba7d185a4079d3c7bedaf"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#aef8c4efd980ba7d185a4079d3c7bedaf">play</a> () override</td></tr>
<tr class="separator:aef8c4efd980ba7d185a4079d3c7bedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c3be9e651bb31e2084293db4d617e0"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a56c3be9e651bb31e2084293db4d617e0">stop</a> () override</td></tr>
<tr class="separator:a56c3be9e651bb31e2084293db4d617e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00393c7aa4f4f0419ffc393bebf00e4"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae00393c7aa4f4f0419ffc393bebf00e4">pause</a> () override</td></tr>
<tr class="separator:ae00393c7aa4f4f0419ffc393bebf00e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7348e9604a83b11196ecddf494dec86"><td class="memItemLeft" align="right" valign="top">avsCommon::utils::mediaPlayer::MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ac7348e9604a83b11196ecddf494dec86">resume</a> () override</td></tr>
<tr class="separator:ac7348e9604a83b11196ecddf494dec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a20c190023f20c4b6bedbc15838930e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a5a20c190023f20c4b6bedbc15838930e">getOffsetInMilliseconds</a> () override</td></tr>
<tr class="separator:a5a20c190023f20c4b6bedbc15838930e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271e75fecb39b734cafb9f1260611e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a271e75fecb39b734cafb9f1260611e79">setObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt; observer) override</td></tr>
<tr class="separator:a271e75fecb39b734cafb9f1260611e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overridden PipelineInterface methods.</div></td></tr>
<tr class="memitem:a2511dfe48da19611a02b9e87e939cb7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a2511dfe48da19611a02b9e87e939cb7c">setAppSrc</a> (GstAppSrc *appSrc) override</td></tr>
<tr class="separator:a2511dfe48da19611a02b9e87e939cb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36f33caf12c633b936a3b5a2f054adb"><td class="memItemLeft" align="right" valign="top">GstAppSrc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae36f33caf12c633b936a3b5a2f054adb">getAppSrc</a> () const override</td></tr>
<tr class="separator:ae36f33caf12c633b936a3b5a2f054adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4089dee120a37c3c4f7016c647cfe26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#af4089dee120a37c3c4f7016c647cfe26">setDecoder</a> (GstElement *decoder) override</td></tr>
<tr class="separator:af4089dee120a37c3c4f7016c647cfe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b5f8f2a0cb22299a20de4bfb1d8e11"><td class="memItemLeft" align="right" valign="top">GstElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ab6b5f8f2a0cb22299a20de4bfb1d8e11">getDecoder</a> () const override</td></tr>
<tr class="separator:ab6b5f8f2a0cb22299a20de4bfb1d8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349de9f04e24a208f65357d3ce32ef22"><td class="memItemLeft" align="right" valign="top">GstElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a349de9f04e24a208f65357d3ce32ef22">getPipeline</a> () const override</td></tr>
<tr class="separator:a349de9f04e24a208f65357d3ce32ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bda1306d465d81023f9743e1350f62"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a49bda1306d465d81023f9743e1350f62">queueCallback</a> (const std::function&lt; gboolean()&gt; *callback) override</td></tr>
<tr class="separator:a49bda1306d465d81023f9743e1350f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a></td></tr>
<tr class="memitem:a6ea8410b0e942e263e7b534f88b30ee3 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6ea8410b0e942e263e7b534f88b30ee3">~MediaPlayerInterface</a> ()=default</td></tr>
<tr class="separator:a6ea8410b0e942e263e7b534f88b30ee3 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f7a1d8fe9ef77ead9f9a70e533ffd inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a863f7a1d8fe9ef77ead9f9a70e533ffd">setSource</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt; attachmentReader)=0</td></tr>
<tr class="separator:a863f7a1d8fe9ef77ead9f9a70e533ffd inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b75cc675041653fc26c5e07b7083f33 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memItemLeft" align="right" valign="top">virtual MediaPlayerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6b75cc675041653fc26c5e07b7083f33">setOffset</a> (std::chrono::milliseconds offset)</td></tr>
<tr class="separator:a6b75cc675041653fc26c5e07b7083f33 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad1cf0d69cdeb8046dc012dc4485900cb"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ad1cf0d69cdeb8046dc012dc4485900cb">create</a> ()</td></tr>
<tr class="separator:ad1cf0d69cdeb8046dc012dc4485900cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that handles creation of audio pipeline and playing of audio data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a3084309902d84b2315005fe218ba3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3084309902d84b2315005fe218ba3f">&#9670;&nbsp;</a></span>~MediaPlayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::mediaPlayer::MediaPlayer::~MediaPlayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1cf0d69cdeb8046dc012dc4485900cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cf0d69cdeb8046dc012dc4485900cb">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a> &gt; alexaClientSDK::mediaPlayer::MediaPlayer::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an instance of the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An instance of the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> if successful else a <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ae36f33caf12c633b936a3b5a2f054adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36f33caf12c633b936a3b5a2f054adb">&#9670;&nbsp;</a></span>getAppSrc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GstAppSrc * alexaClientSDK::mediaPlayer::MediaPlayer::getAppSrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the appSrc element of the <code>AudioPipeline</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The appSrc element. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#a9ef094b2a6f10214467c1dd27abe2918">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="ab6b5f8f2a0cb22299a20de4bfb1d8e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b5f8f2a0cb22299a20de4bfb1d8e11">&#9670;&nbsp;</a></span>getDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GstElement * alexaClientSDK::mediaPlayer::MediaPlayer::getDecoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the decoder element of the <code>AudioPipeline</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The decoder element. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#a0103c2aeb1c68c3a7cf6e6adc6634f76">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="a5a20c190023f20c4b6bedbc15838930e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a20c190023f20c4b6bedbc15838930e">&#9670;&nbsp;</a></span>getOffsetInMilliseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t alexaClientSDK::mediaPlayer::MediaPlayer::getOffsetInMilliseconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the offset, in milliseconds, of the media stream.</p>
<dl class="section return"><dt>Returns</dt><dd>If a stream is playing, the offset in milliseconds that the stream has been playing, if there is no stream playing it returns <code>-1</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a31a4f64754a231a7041fba9b5c27d32b">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="a349de9f04e24a208f65357d3ce32ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349de9f04e24a208f65357d3ce32ef22">&#9670;&nbsp;</a></span>getPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GstElement * alexaClientSDK::mediaPlayer::MediaPlayer::getPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the pipeline of the <code>AudioPipeline</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The pipeline. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#a3ef4f189af48cba70ec1cbdb2eb730ae">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="ae00393c7aa4f4f0419ffc393bebf00e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00393c7aa4f4f0419ffc393bebf00e4">&#9670;&nbsp;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pause playing the audio. Once audio has been paused, calling <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ac7348e9604a83b11196ecddf494dec86">resume()</a></code> will start the audio. The source should be set before issuing <code>pause</code>. If <code>pause</code> is called without setting source, it will return an error. Calling <code>pause</code> will only have an effect when audio is currently playing. Calling <code>pause</code> in all other states will have no effect, and result in a return of <code>FAILURE</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to pause was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackPaused</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#aa3dc008a6c4d2b79da4d30d8ae82432b">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="aef8c4efd980ba7d185a4079d3c7bedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8c4efd980ba7d185a4079d3c7bedaf">&#9670;&nbsp;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::play </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start playing audio. The source should be set before issuing <code>play</code>. If <code>play</code> is called without setting source, it will return an error. If <code>play</code> is called when audio is already playing, there is no effect. Status returned will be <code>SUCCESS</code>. If <code>play</code> is called again after <code>stop</code> on the same source, then the audio plays from the beginning.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to play was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackStarted</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a39e55afe1f90c135f767824ea9e7de56">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="a49bda1306d465d81023f9743e1350f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bda1306d465d81023f9743e1350f62">&#9670;&nbsp;</a></span>queueCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">guint alexaClientSDK::mediaPlayer::MediaPlayer::queueCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; gboolean()&gt; *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queue the specified callback for execution on the worker thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the queued callback (for calling <code>g_source_remove</code>). </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#a22d94edce4ea73a296090549f952855b">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="ac7348e9604a83b11196ecddf494dec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7348e9604a83b11196ecddf494dec86">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To resume playback after a pause, call <code>resume</code>. Calling <code>play</code> will reset the pipeline and source, and will not resume playback. </p>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#afb22095833dc3e9967fdb45c289332bd">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="a2511dfe48da19611a02b9e87e939cb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2511dfe48da19611a02b9e87e939cb7c">&#9670;&nbsp;</a></span>setAppSrc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::MediaPlayer::setAppSrc </td>
          <td>(</td>
          <td class="paramtype">GstAppSrc *&#160;</td>
          <td class="paramname"><em>appSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the appSrc element in the <code>AudioPipeline</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appSrc</td><td>The element the appSrc of <code>AudioPipeline</code> should be set to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#ab03a69c41562d2ec870b0702391bda3c">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="af4089dee120a37c3c4f7016c647cfe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4089dee120a37c3c4f7016c647cfe26">&#9670;&nbsp;</a></span>setDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::MediaPlayer::setDecoder </td>
          <td>(</td>
          <td class="paramtype">GstElement *&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the decoder element in the <code>AudioPipeline</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>The element the decoder of <code>AudioPipeline</code> should be set to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_pipeline_interface.html#a16c058802b632a9b0f1b0bfc8a369e4d">alexaClientSDK::mediaPlayer::PipelineInterface</a>.</p>

</div>
</div>
<a id="a271e75fecb39b734cafb9f1260611e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271e75fecb39b734cafb9f1260611e79">&#9670;&nbsp;</a></span>setObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::MediaPlayer::setObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>playerObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets an observer to be notified when playback state changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playerObserver</td><td>The observer to send the notifications to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a612495025a57c1bab88e8be5f7c0bbf4">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="a1b20efddb45b45a9347a75be8f7f05ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b20efddb45b45a9347a75be8f7f05ad">&#9670;&nbsp;</a></span>setSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; std::istream &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source to play. The source should be set before issuing <code>play</code> or <code>stop</code>.</p>
<p>The <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> can handle only one source at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Object with which to read an incoming audio stream. </td></tr>
    <tr><td class="paramname">repeat</td><td>Whether the audio stream should be played in a loop until stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the the source was set successfully else <code>FAILURE</code>. If setSource is called when audio is currently playing, the playing audio will be stopped and the source set to the new value. If there is an error stopping the player, this will return <code>FAILURE</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#af938277a89ad00f5d4b1884dee16080f">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="ae302858b924dc8600e5a10a754d299a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae302858b924dc8600e5a10a754d299a2">&#9670;&nbsp;</a></span>setSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source to play. The source should be set before issuing <code>play</code> or <code>stop</code>.</p>
<p>The <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> can handle only one source at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to set as the source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the source was set successfully else <code>FAILURE</code>. If setSource is called when audio is currently playing, the playing audio will be stopped and the source set to the new value. If there is an error stopping the player, this will return <code>FAILURE</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6df36422c7caadefdd438f4c938ed7e4">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<a id="a56c3be9e651bb31e2084293db4d617e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c3be9e651bb31e2084293db4d617e0">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MediaPlayerStatus alexaClientSDK::mediaPlayer::MediaPlayer::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop playing the audio. Once audio has been stopped, starting playback again will start from the beginning. The source should be set before issuing <code>stop</code>. If <code>stop</code> is called without setting source, it will return an error. If <code>stop</code> is called when audio has already stopped, there is no effect. Status returned will be <code>SUCCESS</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>SUCCESS</code> if the state transition to stop was successful. If state transition is pending then it returns <code>PENDING</code> and the state transition status is notified via <code>onPlaybackStarted</code> or <code>onPlaybackError</code>. If state transition was unsuccessful, returns <code>FAILURE</code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ac7034677f0614203a26f31475f16e324">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/kcecka/projects/avs-cpp-sdk/MediaPlayer/include/MediaPlayer/<a class="el" href="_media_player_8h_source.html">MediaPlayer.h</a></li>
<li>/Users/kcecka/projects/avs-cpp-sdk/MediaPlayer/src/MediaPlayer.cpp</li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 1.0.1 - Copyright 2016-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
